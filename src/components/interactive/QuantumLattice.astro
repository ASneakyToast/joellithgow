---
// Quantum Lattice WebGL Animation Component
// Only renders when quantum theme is active
export interface Props {
  variant?: 'hero' | 'footer';
}

const { variant = 'hero' } = Astro.props;
---

<div class={`quantum-lattice-container quantum-lattice-${variant}`} data-quantum-canvas>
  <canvas class="quantum-canvas"></canvas>
</div>

<style>
  .quantum-lattice-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.5s ease;
    z-index: 1;
  }

  /* Only show in quantum theme */
  :global([data-theme="quantum"]) .quantum-lattice-container {
    opacity: 1;
  }

  .quantum-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  .quantum-lattice-footer {
    height: 300px;
  }

  /* Hide on mobile for performance */
  @media (max-width: 768px) {
    .quantum-lattice-container {
      display: none;
    }
  }

  /* Respect reduced motion preference */
  @media (prefers-reduced-motion: reduce) {
    .quantum-lattice-container {
      display: none;
    }
  }
</style>

<script>
  // ═══════════════════════════════════════════════════════════════════════
  // QUANTUM LATTICE - OPTIMIZED WEBGL PARTICLE SYSTEM
  // ═══════════════════════════════════════════════════════════════════════

  interface Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    maxSpeed: number;
    noiseOffsetX: number;
    noiseOffsetY: number;
  }

  class QuantumLattice {
    private canvas: HTMLCanvasElement;
    private gl: WebGL2RenderingContext | WebGLRenderingContext | null;
    private width: number;
    private height: number;
    private params = {
      particleCount: 2000, // Reduced from 5000
      baseFreq: 1.5,
      phaseSpeed: 0.8,
      motionScale: 2.0,
      trailFade: 0.96,
      harmonics: 3
    };
    private particles: Particle[] = [];
    private time = 0;
    private phaseField: number[][] = [];
    private fieldRes = 40;
    private fieldCols = 0;
    private fieldRows = 0;
    private frameCount = 0;
    private animationId: number | null = null;
    private shaderProgram: WebGLProgram | null = null;
    private trailProgram: WebGLProgram | null = null;
    private trailFramebuffer: WebGLFramebuffer | null = null;
    private trailTexture: WebGLTexture | null = null;
    private rng: Random;
    private isQuantumTheme = false;

    // Cached WebGL resources
    private quadBuffer: WebGLBuffer | null = null;
    private circleBuffer: WebGLBuffer | null = null;
    private posBuffer: WebGLBuffer | null = null;
    private colorBuffer: WebGLBuffer | null = null;
    private instanceExt: any = null;

    constructor(canvas: HTMLCanvasElement) {
      this.canvas = canvas;
      this.gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
      this.width = 800; // Fixed reasonable size
      this.height = 800;
      this.rng = new Random(12345);

      if (!this.gl) {
        console.warn('WebGL not supported');
        return;
      }

      this.checkTheme();
      this.setupCanvas();
      this.initWebGL();
      this.initializeSystem();

      this.observeThemeChanges();

      if (this.isQuantumTheme) {
        this.start();
      }
    }

    private checkTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      this.isQuantumTheme = currentTheme === 'quantum';
    }

    private observeThemeChanges() {
      const observer = new MutationObserver(() => {
        const wasQuantum = this.isQuantumTheme;
        this.checkTheme();

        if (this.isQuantumTheme && !wasQuantum) {
          this.start();
        } else if (!this.isQuantumTheme && wasQuantum) {
          this.stop();
        }
      });

      observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['data-theme']
      });
    }

    private setupCanvas() {
      // Use fixed size for better performance
      this.canvas.width = this.width;
      this.canvas.height = this.height;

      if (this.gl) {
        this.gl.viewport(0, 0, this.width, this.height);
      }
    }

    private compileShader(source: string, type: number): WebGLShader | null {
      if (!this.gl) return null;

      const shader = this.gl.createShader(type);
      if (!shader) return null;

      this.gl.shaderSource(shader, source);
      this.gl.compileShader(shader);

      if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
        this.gl.deleteShader(shader);
        return null;
      }

      return shader;
    }

    private createProgram(vertSource: string, fragSource: string): WebGLProgram | null {
      if (!this.gl) return null;

      const vertShader = this.compileShader(vertSource, this.gl.VERTEX_SHADER);
      const fragShader = this.compileShader(fragSource, this.gl.FRAGMENT_SHADER);

      if (!vertShader || !fragShader) return null;

      const program = this.gl.createProgram();
      if (!program) return null;

      this.gl.attachShader(program, vertShader);
      this.gl.attachShader(program, fragShader);
      this.gl.linkProgram(program);

      if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
        console.error('Program link error:', this.gl.getProgramInfoLog(program));
        return null;
      }

      return program;
    }

    private initWebGL() {
      if (!this.gl) return;

      // Particle shaders
      const particleVertexShader = `
        attribute vec2 aPosition;
        attribute vec2 aParticlePos;
        attribute vec3 aColor;

        uniform vec2 uResolution;

        varying vec3 vColor;

        void main() {
          vec2 pos = aPosition * 3.0 + aParticlePos;
          vec2 clipSpace = (pos / uResolution) * 2.0 - 1.0;
          clipSpace.y *= -1.0;

          gl_Position = vec4(clipSpace, 0.0, 1.0);
          vColor = aColor;
        }
      `;

      const particleFragmentShader = `
        precision mediump float;
        varying vec3 vColor;

        void main() {
          gl_FragColor = vec4(vColor, 0.6);
        }
      `;

      // Trail fade shaders
      const trailVertexShader = `
        attribute vec2 aPosition;
        varying vec2 vTexCoord;

        void main() {
          gl_Position = vec4(aPosition, 0.0, 1.0);
          vTexCoord = aPosition * 0.5 + 0.5;
        }
      `;

      const trailFragmentShader = `
        precision mediump float;
        uniform sampler2D uTexture;
        uniform float uFade;
        varying vec2 vTexCoord;

        void main() {
          vec4 color = texture2D(uTexture, vTexCoord);
          gl_FragColor = vec4(color.rgb * uFade, color.a * uFade);
        }
      `;

      this.shaderProgram = this.createProgram(particleVertexShader, particleFragmentShader);
      this.trailProgram = this.createProgram(trailVertexShader, trailFragmentShader);

      // Cache instancing extension
      this.instanceExt = this.gl.getExtension('ANGLE_instanced_arrays');

      // Create reusable buffers
      this.quadBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadBuffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,  1, -1,  -1, 1,
        -1, 1,   1, -1,   1, 1
      ]), this.gl.STATIC_DRAW);

      // Circle vertices
      const circleVerts = [];
      const segments = 8;
      for (let i = 0; i < segments; i++) {
        const angle = (i / segments) * Math.PI * 2;
        circleVerts.push(Math.cos(angle), Math.sin(angle));
      }
      this.circleBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.circleBuffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(circleVerts), this.gl.STATIC_DRAW);

      // Create particle data buffers
      this.posBuffer = this.gl.createBuffer();
      this.colorBuffer = this.gl.createBuffer();

      // Create trail texture and framebuffer
      this.trailTexture = this.gl.createTexture();
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.trailTexture);
      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.width, this.height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);

      this.trailFramebuffer = this.gl.createFramebuffer();
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.trailFramebuffer);
      this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.trailTexture, 0);

      // Clear with background color
      this.gl.clearColor(250/255, 249/255, 245/255, 1.0);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);

      this.gl.enable(this.gl.BLEND);
      this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
    }

    private initializeSystem() {
      this.particles = [];
      this.time = 0;

      this.generatePhaseField();

      const gridSize = Math.ceil(Math.sqrt(this.params.particleCount));
      const spacing = this.width / (gridSize + 1);

      let count = 0;
      for (let i = 0; i < gridSize && count < this.params.particleCount; i++) {
        for (let j = 0; j < gridSize && count < this.params.particleCount; j++) {
          const x = (i + 1) * spacing + this.rng.range(-spacing * 0.1, spacing * 0.1);
          const y = (j + 1) * spacing + this.rng.range(-spacing * 0.1, spacing * 0.1);
          this.particles.push({
            x,
            y,
            vx: 0,
            vy: 0,
            maxSpeed: 2,
            noiseOffsetX: this.rng.next() * 1000,
            noiseOffsetY: this.rng.next() * 1000
          });
          count++;
        }
      }
    }

    private generatePhaseField() {
      this.fieldCols = Math.ceil(this.width / this.fieldRes);
      this.fieldRows = Math.ceil(this.height / this.fieldRes);

      for (let i = 0; i < this.fieldCols; i++) {
        if (!this.phaseField[i]) this.phaseField[i] = [];
        for (let j = 0; j < this.fieldRows; j++) {
          const x = i * this.fieldRes;
          const y = j * this.fieldRes;
          this.phaseField[i][j] = this.calculatePhaseAtPoint(x, y);
        }
      }
    }

    private calculatePhaseAtPoint(x: number, y: number): number {
      let phase = 0;
      const { harmonics, baseFreq, phaseSpeed } = this.params;

      if (harmonics >= 1) {
        const freq = baseFreq * 0.5;
        const timeOffset = this.time * phaseSpeed;
        phase += Math.sin(x * 0.01 * freq + timeOffset);
        phase += Math.sin(y * 0.01 * freq + timeOffset * 1.1);
        phase += Math.sin((x + y) * 0.007 * freq + timeOffset * 0.9);
        phase += Math.sin((x - y) * 0.007 * freq + timeOffset * 1.2);
      }

      if (harmonics >= 2) {
        const freq = baseFreq * 1.0;
        const timeOffset = this.time * phaseSpeed * 1.3;
        phase += Math.sin(x * 0.01 * freq + timeOffset);
        phase += Math.sin(y * 0.01 * freq + timeOffset * 1.1);
      }

      if (harmonics >= 3) {
        const freq = baseFreq * 1.5;
        const timeOffset = this.time * phaseSpeed * 1.6;
        phase += Math.sin(x * 0.01 * freq + timeOffset);
        phase += Math.sin(y * 0.01 * freq + timeOffset * 1.1);
      }

      return phase;
    }

    private getPhaseAtPosition(x: number, y: number): number {
      const col = Math.floor(x / this.fieldRes);
      const row = Math.floor(y / this.fieldRes);

      if (col < 0 || col >= this.fieldCols - 1 || row < 0 || row >= this.fieldRows - 1) {
        return 0;
      }

      const xLerp = (x - col * this.fieldRes) / this.fieldRes;
      const yLerp = (y - row * this.fieldRes) / this.fieldRes;

      const p00 = this.phaseField[col][row];
      const p10 = this.phaseField[col + 1][row];
      const p01 = this.phaseField[col][row + 1];
      const p11 = this.phaseField[col + 1][row + 1];

      const p0 = p00 + (p10 - p00) * xLerp;
      const p1 = p01 + (p11 - p01) * xLerp;

      return p0 + (p1 - p0) * yLerp;
    }

    private noise(x: number, y: number, z: number): number {
      x -= Math.floor(x);
      y -= Math.floor(y);
      z -= Math.floor(z);

      const u = this.fade(x);
      const v = this.fade(y);
      const w = this.fade(z);

      return this.lerp(w, this.lerp(v, this.lerp(u, 0.5, 0.6), this.lerp(u, 0.4, 0.7)),
                         this.lerp(v, this.lerp(u, 0.3, 0.8), this.lerp(u, 0.6, 0.5)));
    }

    private fade(t: number): number {
      return t * t * t * (t * (t * 6 - 15) + 10);
    }

    private lerp(t: number, a: number, b: number): number {
      return a + t * (b - a);
    }

    private updateParticle(p: Particle) {
      const dx = this.fieldRes;
      const phaseRight = this.getPhaseAtPosition(p.x + dx, p.y);
      const phaseLeft = this.getPhaseAtPosition(p.x - dx, p.y);
      const phaseUp = this.getPhaseAtPosition(p.x, p.y - dx);
      const phaseDown = this.getPhaseAtPosition(p.x, p.y + dx);

      const gradX = (phaseRight - phaseLeft) / (2 * dx);
      const gradY = (phaseDown - phaseUp) / (2 * dx);

      const forceScale = this.params.motionScale * 0.1;
      let ax = gradX * forceScale;
      let ay = gradY * forceScale;

      if (this.frameCount % 2 === 0) {
        const nx = this.noise(p.x * 0.003 + p.noiseOffsetX, p.y * 0.003, this.time) - 0.5;
        const ny = this.noise(p.x * 0.003 + p.noiseOffsetY, p.y * 0.003, this.time) - 0.5;
        ax += nx * 0.2;
        ay += ny * 0.2;
      }

      p.vx += ax;
      p.vy += ay;

      const speedSq = p.vx * p.vx + p.vy * p.vy;
      const maxSpeedSq = p.maxSpeed * p.maxSpeed;

      if (speedSq > maxSpeedSq) {
        const speed = Math.sqrt(speedSq);
        p.vx = (p.vx / speed) * p.maxSpeed;
        p.vy = (p.vy / speed) * p.maxSpeed;
      }

      p.x += p.vx;
      p.y += p.vy;

      if (p.x < 0) p.x += this.width;
      else if (p.x > this.width) p.x -= this.width;
      if (p.y < 0) p.y += this.height;
      else if (p.y > this.height) p.y -= this.height;
    }

    private getParticleColor(p: Particle): [number, number, number] {
      const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
      const phase = this.getPhaseAtPosition(p.x, p.y);

      const hue = (phase * 30 + this.time * 10) % 360;
      const brightness = 40 + (speed / p.maxSpeed) * 55;
      const saturation = 30 + (speed / p.maxSpeed) * 50;

      return this.hsbToRgb(hue, saturation, brightness);
    }

    private hsbToRgb(h: number, s: number, b: number): [number, number, number] {
      s /= 100;
      b /= 100;
      const k = (n: number) => (n + h / 60) % 6;
      const f = (n: number) => b * (1 - s * Math.max(0, Math.min(k(n), 4 - k(n), 1)));
      return [f(5), f(3), f(1)];
    }

    private render() {
      if (!this.gl || !this.shaderProgram || !this.trailProgram || !this.trailFramebuffer || !this.trailTexture) return;

      this.time += 0.01;
      this.frameCount++;

      if (this.frameCount % 3 === 0) {
        this.generatePhaseField();
      }

      for (const p of this.particles) {
        this.updateParticle(p);
      }

      // Apply trail fade
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.trailFramebuffer);
      this.gl.useProgram(this.trailProgram);

      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadBuffer);
      const posLoc = this.gl.getAttribLocation(this.trailProgram, 'aPosition');
      this.gl.enableVertexAttribArray(posLoc);
      this.gl.vertexAttribPointer(posLoc, 2, this.gl.FLOAT, false, 0, 0);

      const texLoc = this.gl.getUniformLocation(this.trailProgram, 'uTexture');
      const fadeLoc = this.gl.getUniformLocation(this.trailProgram, 'uFade');

      this.gl.activeTexture(this.gl.TEXTURE0);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.trailTexture);
      this.gl.uniform1i(texLoc, 0);
      this.gl.uniform1f(fadeLoc, this.params.trailFade);

      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);

      // Draw particles
      this.gl.useProgram(this.shaderProgram);

      // Update particle positions and colors
      const positions = new Float32Array(this.particles.length * 2);
      const colors = new Float32Array(this.particles.length * 3);

      for (let i = 0; i < this.particles.length; i++) {
        positions[i * 2] = this.particles[i].x;
        positions[i * 2 + 1] = this.particles[i].y;

        const color = this.getParticleColor(this.particles[i]);
        colors[i * 3] = color[0];
        colors[i * 3 + 1] = color[1];
        colors[i * 3 + 2] = color[2];
      }

      // Circle vertices
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.circleBuffer);
      const aPosition = this.gl.getAttribLocation(this.shaderProgram, 'aPosition');
      this.gl.enableVertexAttribArray(aPosition);
      this.gl.vertexAttribPointer(aPosition, 2, this.gl.FLOAT, false, 0, 0);

      // Particle positions
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.posBuffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.DYNAMIC_DRAW);
      const aParticlePos = this.gl.getAttribLocation(this.shaderProgram, 'aParticlePos');
      this.gl.enableVertexAttribArray(aParticlePos);
      this.gl.vertexAttribPointer(aParticlePos, 2, this.gl.FLOAT, false, 0, 0);

      if (this.instanceExt) {
        this.instanceExt.vertexAttribDivisorANGLE(aParticlePos, 1);
      }

      // Particle colors
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, colors, this.gl.DYNAMIC_DRAW);
      const aColor = this.gl.getAttribLocation(this.shaderProgram, 'aColor');
      this.gl.enableVertexAttribArray(aColor);
      this.gl.vertexAttribPointer(aColor, 3, this.gl.FLOAT, false, 0, 0);

      if (this.instanceExt) {
        this.instanceExt.vertexAttribDivisorANGLE(aColor, 1);
      }

      const resLoc = this.gl.getUniformLocation(this.shaderProgram, 'uResolution');
      this.gl.uniform2f(resLoc, this.width, this.height);

      // Draw instanced
      if (this.instanceExt) {
        this.instanceExt.drawArraysInstancedANGLE(this.gl.TRIANGLE_FAN, 0, 8, this.particles.length);
      } else {
        for (let i = 0; i < this.particles.length; i++) {
          this.gl.drawArrays(this.gl.TRIANGLE_FAN, 0, 8);
        }
      }

      // Render to screen
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
      this.gl.viewport(0, 0, this.width, this.height);

      this.gl.useProgram(this.trailProgram);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadBuffer);
      this.gl.enableVertexAttribArray(posLoc);
      this.gl.vertexAttribPointer(posLoc, 2, this.gl.FLOAT, false, 0, 0);

      this.gl.activeTexture(this.gl.TEXTURE0);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.trailTexture);
      this.gl.uniform1i(texLoc, 0);
      this.gl.uniform1f(fadeLoc, 1.0);

      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    }

    public start() {
      if (this.animationId !== null) return;

      const animate = () => {
        this.render();
        this.animationId = requestAnimationFrame(animate);
      };

      animate();
    }

    public stop() {
      if (this.animationId !== null) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
      }
    }
  }

  // Simple PRNG
  class Random {
    private seed: number;

    constructor(seed: number) {
      this.seed = seed;
    }

    next(): number {
      this.seed = (this.seed * 9301 + 49297) % 233280;
      return this.seed / 233280;
    }

    range(min: number, max: number): number {
      return min + this.next() * (max - min);
    }
  }

  // Initialize all quantum lattice canvases
  document.addEventListener('DOMContentLoaded', () => {
    const containers = document.querySelectorAll('[data-quantum-canvas]');

    containers.forEach(container => {
      const canvas = container.querySelector('canvas');
      if (canvas instanceof HTMLCanvasElement) {
        new QuantumLattice(canvas);
      }
    });
  });
</script>
