---
// Cellular Automata Storm - Pure WebGL Interactive Artwork
const pageTitle = 'Cellular Automata Storm - Creative Coding';
const pageDescription = "Conway's Game of Life meets particle physics in this dynamic visualization where cellular birth and death events emit beautiful particle storms.";
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{pageTitle}</title>
    <meta name="description" content={pageDescription}>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&family=Lora:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --anthropic-dark: #141413;
            --anthropic-light: #faf9f5;
            --anthropic-mid-gray: #b0aea5;
            --anthropic-light-gray: #e8e6dc;
            --anthropic-orange: #d97757;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, var(--anthropic-light) 0%, #f5f3ee 100%);
            min-height: 100vh;
            color: var(--anthropic-dark);
        }

        /* Back to Gallery Link */
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1100;
            background: var(--anthropic-dark);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(20, 20, 19, 0.2);
        }

        .back-link:hover {
            background: #2a2a27;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(20, 20, 19, 0.3);
        }

        .container {
            display: flex;
            min-height: 100vh;
            padding: 20px;
            gap: 20px;
        }

        .sidebar {
            width: 320px;
            flex-shrink: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(20, 20, 19, 0.1);
            overflow-y: auto;
        }

        .sidebar h1 {
            font-family: 'Lora', serif;
            font-size: 24px;
            font-weight: 500;
            color: var(--anthropic-dark);
            margin-bottom: 8px;
        }

        .sidebar .subtitle {
            color: var(--anthropic-mid-gray);
            font-size: 14px;
            margin-bottom: 32px;
            line-height: 1.4;
        }

        .control-section {
            margin-bottom: 32px;
        }

        .control-section h3 {
            font-size: 16px;
            font-weight: 600;
            color: var(--anthropic-dark);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-section h3::before {
            content: '•';
            color: var(--anthropic-orange);
            font-weight: bold;
        }

        .seed-input {
            width: 100%;
            background: var(--anthropic-light);
            padding: 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin-bottom: 12px;
            border: 1px solid var(--anthropic-light-gray);
            text-align: center;
        }

        .seed-input:focus {
            outline: none;
            border-color: var(--anthropic-orange);
            box-shadow: 0 0 0 2px rgba(217, 119, 87, 0.1);
            background: white;
        }

        .seed-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: var(--anthropic-dark);
            margin-bottom: 8px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .slider-container input[type="range"] {
            flex: 1;
            height: 4px;
            background: var(--anthropic-light-gray);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--anthropic-orange);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: #c86641;
        }

        .slider-container input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--anthropic-orange);
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .value-display {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: var(--anthropic-mid-gray);
            min-width: 60px;
            text-align: right;
        }

        .button {
            width: 100%;
            padding: 12px 16px;
            background: var(--anthropic-dark);
            color: white;
            border: none;
            border-radius: 8px;
            font-family: 'Poppins', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .button:hover {
            background: #2a2a27;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(20, 20, 19, 0.2);
        }

        .button:active {
            transform: translateY(0);
        }

        .button-row {
            display: flex;
            gap: 8px;
        }

        .button-row .button {
            flex: 1;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #canvas-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(20, 20, 19, 0.15);
            overflow: hidden;
            position: relative;
        }

        canvas {
            display: block;
        }

        .fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(20, 20, 19, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: 600;
            z-index: 10;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                max-width: 600px;
                margin: 0 auto;
            }

            #canvas-container canvas {
                max-width: 100%;
                height: auto;
            }

            .back-link {
                top: 10px;
                left: 10px;
                padding: 10px 16px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <a href="/creative-coding" class="back-link">← Back to Gallery</a>

    <div class="container">
        <div class="sidebar">
            <h1>Cellular Automata Storm</h1>
            <p class="subtitle">Game of Life meets particle physics • Seed generates all parameters</p>

            <div class="control-section">
                <h3>Seed</h3>
                <input type="text" id="seed-input" class="seed-input" value="12345" onchange="updateSeed()">
                <div class="seed-controls">
                    <button class="button" onclick="previousSeed()">← Prev</button>
                    <button class="button" onclick="nextSeed()">Next →</button>
                </div>
                <button class="button" onclick="randomSeedAndUpdate()">Random Seed</button>
            </div>

            <div class="control-section">
                <h3>Cellular Grid</h3>

                <div class="control-group">
                    <label>Grid Resolution</label>
                    <div class="slider-container">
                        <input type="range" id="gridSize" min="40" max="150" step="10" value="80" oninput="updateParam('gridSize', this.value)">
                        <span class="value-display" id="gridSize-value">80</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Update Rate (frames)</label>
                    <div class="slider-container">
                        <input type="range" id="updateRate" min="1" max="10" step="1" value="3" oninput="updateParam('updateRate', this.value)">
                        <span class="value-display" id="updateRate-value">3</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Initial Density</label>
                    <div class="slider-container">
                        <input type="range" id="initialDensity" min="0.1" max="0.6" step="0.05" value="0.3" oninput="updateParam('initialDensity', this.value)">
                        <span class="value-display" id="initialDensity-value">0.30</span>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h3>Particle Emission</h3>

                <div class="control-group">
                    <label>Birth Particles</label>
                    <div class="slider-container">
                        <input type="range" id="birthParticles" min="1" max="20" step="1" value="8" oninput="updateParam('birthParticles', this.value)">
                        <span class="value-display" id="birthParticles-value">8</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Death Particles</label>
                    <div class="slider-container">
                        <input type="range" id="deathParticles" min="1" max="15" step="1" value="5" oninput="updateParam('deathParticles', this.value)">
                        <span class="value-display" id="deathParticles-value">5</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Emission Velocity</label>
                    <div class="slider-container">
                        <input type="range" id="emissionVelocity" min="0.5" max="5.0" step="0.1" value="2.0" oninput="updateParam('emissionVelocity', this.value)">
                        <span class="value-display" id="emissionVelocity-value">2.0</span>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h3>Visual</h3>

                <div class="control-group">
                    <label>Trail Fade</label>
                    <div class="slider-container">
                        <input type="range" id="trailFade" min="0.85" max="0.99" step="0.01" value="0.95" oninput="updateParam('trailFade', this.value)">
                        <span class="value-display" id="trailFade-value">0.95</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Particle Lifespan</label>
                    <div class="slider-container">
                        <input type="range" id="particleLifespan" min="100" max="1000" step="50" value="400" oninput="updateParam('particleLifespan', this.value)">
                        <span class="value-display" id="particleLifespan-value">400</span>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h3>Actions</h3>
                <div class="button-row">
                    <button class="button" onclick="resetParameters()">Reset</button>
                    <button class="button" onclick="clearAndRestart()">Restart</button>
                </div>
            </div>
        </div>

        <div class="canvas-area">
            <div id="canvas-container">
                <canvas id="glCanvas" width="1200" height="1200"></canvas>
                <div class="fps-counter" id="fps-counter">FPS: --</div>
            </div>
        </div>
    </div>

    <script is:inline>
        // ═══════════════════════════════════════════════════════════════════════
        // CELLULAR AUTOMATA STORM - PURE WEBGL
        // ═══════════════════════════════════════════════════════════════════════

        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported');
        }

        // Parameters
        let params = {
            seed: 12345,
            gridSize: 80,
            updateRate: 3,
            initialDensity: 0.3,
            birthParticles: 8,
            deathParticles: 5,
            emissionVelocity: 2.0,
            trailFade: 0.95,
            particleLifespan: 400
        };

        let defaultParams = {...params};

        // System state
        let width = 1200, height = 1200;
        let cellGrid = [];
        let cellAges = [];
        let nextGrid = [];
        let particles = [];
        let frameCount = 0;
        let cellSize;

        // FPS tracking
        let fps = 60;
        let frameTimeSum = 0;
        let frameTimeCount = 0;
        let lastFrameTime = performance.now();

        // WebGL resources
        let particleProgram;
        let trailProgram;
        let trailFramebuffer;
        let trailTexture;

        // Random number generator
        class Random {
            constructor(seed) {
                this.seed = seed;
            }

            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }

            range(min, max) {
                return min + this.next() * (max - min);
            }
        }

        let rng = new Random(params.seed);
        let colorPalette = null;

        // Generate color palette based on seed
        function generateColorPalette(seed) {
            const paletteRng = new Random(seed);

            // Choose a random palette theme
            const themes = [
                'warm', 'cool', 'neon', 'pastel', 'monochrome',
                'sunset', 'ocean', 'forest', 'fire', 'ice'
            ];
            const theme = themes[Math.floor(paletteRng.next() * themes.length)];

            let palette = {};

            switch(theme) {
                case 'warm':
                    palette.birthHueBase = paletteRng.range(0, 60); // Red-yellow
                    palette.birthHueRange = 40;
                    palette.deathHueBase = paletteRng.range(20, 80);
                    palette.deathHueRange = 30;
                    break;

                case 'cool':
                    palette.birthHueBase = paletteRng.range(180, 280); // Cyan-blue-purple
                    palette.birthHueRange = 50;
                    palette.deathHueBase = paletteRng.range(200, 320);
                    palette.deathHueRange = 40;
                    break;

                case 'neon':
                    palette.birthHueBase = paletteRng.range(0, 360);
                    palette.birthHueRange = 80;
                    palette.deathHueBase = (palette.birthHueBase + 120) % 360;
                    palette.deathHueRange = 80;
                    palette.saturationBoost = 20;
                    palette.brightnessBoost = 20;
                    break;

                case 'pastel':
                    palette.birthHueBase = paletteRng.range(0, 360);
                    palette.birthHueRange = 60;
                    palette.deathHueBase = (palette.birthHueBase + 180) % 360;
                    palette.deathHueRange = 60;
                    palette.saturationReduction = 40;
                    palette.brightnessBoost = 15;
                    break;

                case 'monochrome':
                    palette.birthHueBase = paletteRng.range(0, 360);
                    palette.birthHueRange = 20;
                    palette.deathHueBase = palette.birthHueBase;
                    palette.deathHueRange = 20;
                    break;

                case 'sunset':
                    palette.birthHueBase = paletteRng.range(340, 40); // Red-orange-yellow
                    palette.birthHueRange = 50;
                    palette.deathHueBase = paletteRng.range(250, 290); // Purple
                    palette.deathHueRange = 30;
                    break;

                case 'ocean':
                    palette.birthHueBase = paletteRng.range(180, 220); // Cyan-blue
                    palette.birthHueRange = 40;
                    palette.deathHueBase = paletteRng.range(200, 260); // Blue-purple
                    palette.deathHueRange = 40;
                    break;

                case 'forest':
                    palette.birthHueBase = paletteRng.range(80, 140); // Yellow-green
                    palette.birthHueRange = 40;
                    palette.deathHueBase = paletteRng.range(120, 200); // Green-cyan
                    palette.deathHueRange = 50;
                    break;

                case 'fire':
                    palette.birthHueBase = paletteRng.range(0, 30); // Red-orange
                    palette.birthHueRange = 40;
                    palette.deathHueBase = paletteRng.range(30, 60); // Orange-yellow
                    palette.deathHueRange = 30;
                    palette.saturationBoost = 15;
                    break;

                case 'ice':
                    palette.birthHueBase = paletteRng.range(180, 240); // Cyan-blue
                    palette.birthHueRange = 40;
                    palette.deathHueBase = paletteRng.range(240, 280); // Blue-purple
                    palette.deathHueRange = 30;
                    palette.saturationReduction = 20;
                    palette.brightnessBoost = 10;
                    break;
            }

            // Set defaults for optional properties
            palette.saturationBoost = palette.saturationBoost || 0;
            palette.saturationReduction = palette.saturationReduction || 0;
            palette.brightnessBoost = palette.brightnessBoost || 0;
            palette.theme = theme;

            return palette;
        }

        // Particle class
        class Particle {
            constructor(x, y, vx, vy, type, age) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.type = type; // 'birth' or 'death'
                this.cellAge = age; // Age of the cell that spawned this particle
                this.life = params.particleLifespan;
                this.maxLife = params.particleLifespan;

                // Add per-particle variation for unique colors
                this.hueOffset = rng.range(-25, 25);
                this.satOffset = rng.range(-10, 10);
                this.brightOffset = rng.range(-8, 8);
                this.birthX = x; // Remember birth position
                this.birthY = y;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // Friction
                this.vx *= 0.99;
                this.vy *= 0.99;

                this.life--;

                // Wrap around edges
                if (this.x < 0) this.x += width;
                if (this.x > width) this.x -= width;
                if (this.y < 0) this.y += height;
                if (this.y > height) this.y -= height;
            }

            isDead() {
                return this.life <= 0;
            }

            getColor() {
                const lifeRatio = this.life / this.maxLife;
                const ageRatio = Math.min(this.cellAge / 100, 1);

                // Spatial variation based on birth position
                const spatialHue = ((this.birthX + this.birthY) / (width + height)) * 60 - 30;

                // Velocity-based color shift
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const velocityHue = speed * 8;

                // Temporal shimmer
                const timeShimmer = Math.sin(frameCount * 0.02 + this.birthX * 0.01) * 8;

                let hue, saturation, brightness;

                if (this.type === 'birth') {
                    // Use palette-defined birth colors with enhancements
                    hue = colorPalette.birthHueBase + (ageRatio * colorPalette.birthHueRange);
                    hue += this.hueOffset; // Per-particle randomness
                    hue += spatialHue * 0.3; // Spatial variation
                    hue += velocityHue; // Velocity influence
                    hue = hue % 360;

                    saturation = 70 + (ageRatio * 25) + colorPalette.saturationBoost - colorPalette.saturationReduction;
                    saturation += this.satOffset; // Per-particle variation
                    saturation += speed * 3; // Faster = more saturated

                    brightness = 55 + (lifeRatio * 35) + colorPalette.brightnessBoost;
                    brightness += this.brightOffset; // Per-particle variation
                    brightness += timeShimmer; // Temporal shimmer
                } else {
                    // Use palette-defined death colors with enhancements
                    hue = colorPalette.deathHueBase + (ageRatio * colorPalette.deathHueRange);
                    hue += this.hueOffset * 0.8; // Per-particle randomness (slightly less)
                    hue += spatialHue * 0.25; // Spatial variation
                    hue -= velocityHue * 0.5; // Velocity influence (opposite direction)
                    hue = hue % 360;

                    saturation = 55 + (ageRatio * 35) + colorPalette.saturationBoost - colorPalette.saturationReduction;
                    saturation += this.satOffset; // Per-particle variation
                    saturation += speed * 2; // Faster = more saturated

                    brightness = 35 + (lifeRatio * 45) + colorPalette.brightnessBoost;
                    brightness += this.brightOffset; // Per-particle variation
                    brightness -= timeShimmer * 0.5; // Temporal shimmer (inverse for death)
                }

                // Clamp values
                saturation = Math.max(0, Math.min(100, saturation));
                brightness = Math.max(0, Math.min(100, brightness));

                return hsbToRgb(hue, saturation, brightness);
            }
        }

        function hsbToRgb(h, s, b) {
            s /= 100;
            b /= 100;
            const k = (n) => (n + h / 60) % 6;
            const f = (n) => b * (1 - s * Math.max(0, Math.min(k(n), 4 - k(n), 1)));
            return [f(5), f(3), f(1)];
        }

        // Cellular Automata functions
        function initializeGrid() {
            const gridSize = params.gridSize;
            cellSize = width / gridSize;

            cellGrid = [];
            cellAges = [];
            nextGrid = [];

            for (let i = 0; i < gridSize; i++) {
                cellGrid[i] = [];
                cellAges[i] = [];
                nextGrid[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    cellGrid[i][j] = rng.next() < params.initialDensity ? 1 : 0;
                    cellAges[i][j] = 0;
                    nextGrid[i][j] = 0;
                }
            }
        }

        function countNeighbors(i, j) {
            const gridSize = params.gridSize;
            let count = 0;

            for (let di = -1; di <= 1; di++) {
                for (let dj = -1; dj <= 1; dj++) {
                    if (di === 0 && dj === 0) continue;

                    const ni = (i + di + gridSize) % gridSize;
                    const nj = (j + dj + gridSize) % gridSize;
                    count += cellGrid[ni][nj];
                }
            }

            return count;
        }

        function updateCellularAutomata() {
            const gridSize = params.gridSize;

            // Calculate next generation
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const neighbors = countNeighbors(i, j);
                    const alive = cellGrid[i][j];

                    // Conway's Game of Life rules
                    if (alive) {
                        nextGrid[i][j] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
                    } else {
                        nextGrid[i][j] = (neighbors === 3) ? 1 : 0;
                    }
                }
            }

            // Apply next generation and emit particles
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const wasAlive = cellGrid[i][j];
                    const nowAlive = nextGrid[i][j];

                    if (nowAlive && !wasAlive) {
                        // Birth - emit particles
                        emitBirthParticles(i, j);
                        cellAges[i][j] = 1;
                    } else if (!nowAlive && wasAlive) {
                        // Death - emit particles
                        emitDeathParticles(i, j, cellAges[i][j]);
                        cellAges[i][j] = 0;
                    } else if (nowAlive) {
                        // Still alive - age increases
                        cellAges[i][j]++;
                    }

                    cellGrid[i][j] = nextGrid[i][j];
                }
            }
        }

        function emitBirthParticles(gridX, gridY) {
            const x = (gridX + 0.5) * cellSize;
            const y = (gridY + 0.5) * cellSize;
            const count = params.birthParticles;

            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2 + rng.range(-0.5, 0.5);
                const speed = params.emissionVelocity * rng.range(0.5, 1.5);
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;

                particles.push(new Particle(x, y, vx, vy, 'birth', 1));
            }
        }

        function emitDeathParticles(gridX, gridY, age) {
            const x = (gridX + 0.5) * cellSize;
            const y = (gridY + 0.5) * cellSize;
            const count = params.deathParticles;

            // Calculate direction based on neighbor gradient
            const gridSize = params.gridSize;
            let dx = 0, dy = 0;

            for (let di = -1; di <= 1; di++) {
                for (let dj = -1; dj <= 1; dj++) {
                    const ni = (gridX + di + gridSize) % gridSize;
                    const nj = (gridY + dj + gridSize) % gridSize;
                    if (cellGrid[ni][nj]) {
                        dx += di;
                        dy += dj;
                    }
                }
            }

            const baseAngle = Math.atan2(dy, dx);

            for (let i = 0; i < count; i++) {
                const angle = baseAngle + rng.range(-1, 1);
                const speed = params.emissionVelocity * rng.range(0.3, 1.0);
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;

                particles.push(new Particle(x, y, vx, vy, 'death', age));
            }
        }

        // Shader code
        const particleVertexShader = `
            attribute vec2 aPosition;
            attribute vec2 aParticlePos;
            attribute vec3 aColor;

            uniform vec2 uResolution;

            varying vec3 vColor;

            void main() {
                vec2 pos = aPosition * 2.5 + aParticlePos;
                vec2 clipSpace = (pos / uResolution) * 2.0 - 1.0;
                clipSpace.y *= -1.0;

                gl_Position = vec4(clipSpace, 0.0, 1.0);
                vColor = aColor;
            }
        `;

        const particleFragmentShader = `
            precision mediump float;
            varying vec3 vColor;

            void main() {
                vec2 center = gl_PointCoord - 0.5;
                float dist = length(center);
                if (dist > 0.5) discard;

                float alpha = 0.7 * (1.0 - dist * 2.0);
                gl_FragColor = vec4(vColor, alpha);
            }
        `;

        const trailVertexShader = `
            attribute vec2 aPosition;
            varying vec2 vTexCoord;

            void main() {
                gl_Position = vec4(aPosition, 0.0, 1.0);
                vTexCoord = aPosition * 0.5 + 0.5;
            }
        `;

        const trailFragmentShader = `
            precision mediump float;
            uniform sampler2D uTexture;
            uniform float uFade;
            varying vec2 vTexCoord;

            void main() {
                vec4 color = texture2D(uTexture, vTexCoord);
                gl_FragColor = vec4(color.rgb * uFade, color.a * uFade);
            }
        `;

        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                return null;
            }

            return shader;
        }

        function createProgram(vertSource, fragSource) {
            const vertShader = compileShader(vertSource, gl.VERTEX_SHADER);
            const fragShader = compileShader(fragSource, gl.FRAGMENT_SHADER);

            const program = gl.createProgram();
            gl.attachShader(program, vertShader);
            gl.attachShader(program, fragShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program error:', gl.getProgramInfoLog(program));
                return null;
            }

            return program;
        }

        function initWebGL() {
            particleProgram = createProgram(particleVertexShader, particleFragmentShader);
            trailProgram = createProgram(trailVertexShader, trailFragmentShader);

            trailTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, trailTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            trailFramebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, trailFramebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, trailTexture, 0);

            gl.clearColor(10/255, 10/255, 15/255, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        }

        let manualOverride = false; // Track if user has manually changed parameters

        function generateSeedBasedParameters() {
            // Only generate if not manually overridden
            if (manualOverride) return;

            // Use seed to generate a unique parameter set
            const paramRng = new Random(params.seed);

            // Grid resolution: prefer specific ranges for interesting dynamics
            const gridChoices = [60, 70, 80, 90, 100, 120];
            params.gridSize = gridChoices[Math.floor(paramRng.next() * gridChoices.length)];

            // Update rate: affects speed of evolution
            const rateChoices = [2, 3, 4, 5];
            params.updateRate = rateChoices[Math.floor(paramRng.next() * rateChoices.length)];

            // Initial density: affects pattern complexity
            params.initialDensity = paramRng.range(0.25, 0.4);

            // Birth particles: young worlds vs mature worlds
            params.birthParticles = Math.floor(paramRng.range(5, 15));

            // Death particles: chaotic vs calm deaths
            params.deathParticles = Math.floor(paramRng.range(3, 12));

            // Emission velocity: explosive vs gentle
            params.emissionVelocity = paramRng.range(1.0, 4.0);

            // Trail fade: memory length
            params.trailFade = paramRng.range(0.90, 0.98);

            // Particle lifespan: short-lived vs long memories
            params.particleLifespan = Math.floor(paramRng.range(200, 600));

            // Update all UI sliders to reflect seed-based parameters
            updateAllSliders();
        }

        function updateAllSliders() {
            document.getElementById('gridSize').value = params.gridSize;
            document.getElementById('gridSize-value').textContent = params.gridSize;

            document.getElementById('updateRate').value = params.updateRate;
            document.getElementById('updateRate-value').textContent = params.updateRate;

            document.getElementById('initialDensity').value = params.initialDensity;
            document.getElementById('initialDensity-value').textContent = params.initialDensity.toFixed(2);

            document.getElementById('birthParticles').value = params.birthParticles;
            document.getElementById('birthParticles-value').textContent = params.birthParticles;

            document.getElementById('deathParticles').value = params.deathParticles;
            document.getElementById('deathParticles-value').textContent = params.deathParticles;

            document.getElementById('emissionVelocity').value = params.emissionVelocity;
            document.getElementById('emissionVelocity-value').textContent = params.emissionVelocity.toFixed(1);

            document.getElementById('trailFade').value = params.trailFade;
            document.getElementById('trailFade-value').textContent = params.trailFade.toFixed(2);

            document.getElementById('particleLifespan').value = params.particleLifespan;
            document.getElementById('particleLifespan-value').textContent = params.particleLifespan;
        }

        function initializeSystem() {
            // Generate seed-based parameters first
            generateSeedBasedParameters();

            // Then initialize RNG and palette
            rng = new Random(params.seed);
            colorPalette = generateColorPalette(params.seed);
            particles = [];
            frameCount = 0;

            console.log('Seed', params.seed, '- Theme:', colorPalette.theme, '- Grid:', params.gridSize, '- Rate:', params.updateRate);

            initializeGrid();

            gl.bindFramebuffer(gl.FRAMEBUFFER, trailFramebuffer);
            gl.clearColor(10/255, 10/255, 15/255, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }

        function render() {
            // FPS tracking
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            frameTimeSum += deltaTime;
            frameTimeCount++;

            if (frameTimeCount >= 10) {
                fps = Math.round(1000 / (frameTimeSum / frameTimeCount));
                document.getElementById('fps-counter').textContent = 'FPS: ' + fps;
                frameTimeSum = 0;
                frameTimeCount = 0;
            }

            frameCount++;

            // Update cellular automata
            if (frameCount % params.updateRate === 0) {
                updateCellularAutomata();
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].isDead()) {
                    particles.splice(i, 1);
                }
            }

            // Limit total particles
            if (particles.length > 50000) {
                particles = particles.slice(-50000);
            }

            // Apply trail fade
            gl.bindFramebuffer(gl.FRAMEBUFFER, trailFramebuffer);
            gl.useProgram(trailProgram);

            const quadBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1,  1, -1,  -1, 1,
                -1, 1,   1, -1,   1, 1
            ]), gl.STATIC_DRAW);

            const posLoc = gl.getAttribLocation(trailProgram, 'aPosition');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            const texLoc = gl.getUniformLocation(trailProgram, 'uTexture');
            const fadeLoc = gl.getUniformLocation(trailProgram, 'uFade');

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, trailTexture);
            gl.uniform1i(texLoc, 0);
            gl.uniform1f(fadeLoc, params.trailFade);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Draw particles
            if (particles.length > 0) {
                gl.useProgram(particleProgram);

                const positions = new Float32Array(particles.length * 2);
                const colors = new Float32Array(particles.length * 3);

                for (let i = 0; i < particles.length; i++) {
                    positions[i * 2] = particles[i].x;
                    positions[i * 2 + 1] = particles[i].y;

                    const color = particles[i].getColor();
                    colors[i * 3] = color[0];
                    colors[i * 3 + 1] = color[1];
                    colors[i * 3 + 2] = color[2];
                }

                const circleVerts = [];
                const segments = 8;
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    circleVerts.push(Math.cos(angle), Math.sin(angle));
                }

                const circleBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, circleBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(circleVerts), gl.STATIC_DRAW);

                const aPosition = gl.getAttribLocation(particleProgram, 'aPosition');
                gl.enableVertexAttribArray(aPosition);
                gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);

                const aParticlePos = gl.getAttribLocation(particleProgram, 'aParticlePos');
                gl.enableVertexAttribArray(aParticlePos);
                gl.vertexAttribPointer(aParticlePos, 2, gl.FLOAT, false, 0, 0);

                if (gl.vertexAttribDivisor) {
                    gl.vertexAttribDivisor(aParticlePos, 1);
                }

                const colorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colors, gl.DYNAMIC_DRAW);

                const aColor = gl.getAttribLocation(particleProgram, 'aColor');
                gl.enableVertexAttribArray(aColor);
                gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

                if (gl.vertexAttribDivisor) {
                    gl.vertexAttribDivisor(aColor, 1);
                }

                const resLoc = gl.getUniformLocation(particleProgram, 'uResolution');
                gl.uniform2f(resLoc, width, height);

                if (gl.drawArraysInstanced) {
                    gl.drawArraysInstanced(gl.TRIANGLE_FAN, 0, segments, particles.length);
                }
            }

            // Render to screen
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, width, height);

            gl.useProgram(trailProgram);
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, trailTexture);
            gl.uniform1i(texLoc, 0);
            gl.uniform1f(fadeLoc, 1.0);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }

        // UI Functions
        function updateParam(paramName, value) {
            const numValue = parseFloat(value);
            params[paramName] = numValue;
            manualOverride = true; // User is manually adjusting parameters

            document.getElementById(paramName + '-value').textContent =
                (paramName === 'initialDensity' || paramName === 'trailFade' || paramName === 'emissionVelocity') ? numValue.toFixed(2) : numValue;

            if (paramName === 'gridSize' || paramName === 'initialDensity') {
                // Don't regenerate all params, just reinitialize with current settings
                rng = new Random(params.seed);
                particles = [];
                frameCount = 0;
                initializeGrid();

                gl.bindFramebuffer(gl.FRAMEBUFFER, trailFramebuffer);
                gl.clearColor(10/255, 10/255, 15/255, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
        }

        function updateSeedDisplay() {
            document.getElementById('seed-input').value = params.seed;
        }

        function updateSeed() {
            const input = document.getElementById('seed-input');
            const newSeed = parseInt(input.value);
            if (newSeed && newSeed > 0) {
                params.seed = newSeed;
                manualOverride = false; // Reset override flag for new seed
                initializeSystem();
            } else {
                updateSeedDisplay();
            }
        }

        function previousSeed() {
            params.seed = Math.max(1, params.seed - 1);
            manualOverride = false; // Reset override flag for new seed
            updateSeedDisplay();
            initializeSystem();
        }

        function nextSeed() {
            params.seed = params.seed + 1;
            manualOverride = false; // Reset override flag for new seed
            updateSeedDisplay();
            initializeSystem();
        }

        function randomSeedAndUpdate() {
            params.seed = Math.floor(Math.random() * 999999) + 1;
            manualOverride = false; // Reset override flag for new seed
            updateSeedDisplay();
            initializeSystem();
        }

        function clearAndRestart() {
            initializeSystem();
        }

        function resetParameters() {
            params = {...defaultParams};
            manualOverride = false; // Allow seed-based generation again

            updateSeedDisplay();
            initializeSystem();
        }

        // Initialize
        initWebGL();
        initializeSystem();
        updateSeedDisplay();
        requestAnimationFrame(render);
    </script>
</body>
</html>
