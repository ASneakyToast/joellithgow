---
// Snake Game Page - Dedicated page for the Snake game within the Astro site
// Maintains theme system integration and provides seamless navigation
import BaseLayout from '@components/common/BaseLayout.astro';

const pageTitle = 'Snake Game - Joel Lithgow';
const pageDescription = 'Classic Snake game with modern design. Full-screen gaming experience integrated with the portfolio theme system.';
---

<BaseLayout title={pageTitle} description={pageDescription}>
  <!-- Game Canvas -->
  <canvas id="gameCanvas"></canvas>
  
  <!-- Home Navigation Link -->
  <a href="/" class="home-link" id="homeLink" aria-label="Return to homepage">
    <div class="home-brand">
      <span class="home-icon">üè†</span>
      <span class="home-text">Joel Lithgow</span>
    </div>
  </a>
  
  <!-- Theme Toggle Button -->
  <button class="theme-toggle" id="themeToggle" title="Change Theme">
    üé®
  </button>
  
  <!-- Score Panel -->
  <div class="score-panel">
    <div class="score-item">
      <span class="score-label">Score</span>
      <span class="score-value" id="currentScore">0</span>
    </div>
    <div class="score-item">
      <span class="score-label">High Score</span>
      <span class="score-value" id="highScore">0</span>
    </div>
    <div class="score-item">
      <span class="score-label">Level</span>
      <span class="score-value" id="level">1</span>
    </div>
  </div>
  
  <!-- Mobile Controls -->
  <div class="mobile-controls">
    <div class="control-pad">
      <button class="control-btn control-up" data-direction="up">‚Üë</button>
      <button class="control-btn control-down" data-direction="down">‚Üì</button>
      <button class="control-btn control-left" data-direction="left">‚Üê</button>
      <button class="control-btn control-right" data-direction="right">‚Üí</button>
      <button class="control-btn control-pause" id="mobilePause">‚è∏</button>
    </div>
  </div>
  
  <!-- Main Menu -->
  <div id="menuOverlay" class="game-overlay">
    <div class="overlay-content">
      <h1 class="game-title">SNAKE</h1>
      <p class="game-subtitle">Classic arcade game</p>
      <button class="game-btn primary" id="startGame">Start Game</button>
      <button class="game-btn" id="showInstructions">How to Play</button>
    </div>
    <!-- Back to Site button positioned in top-left of menu -->
    <button class="menu-nav-btn menu-back-btn" id="backToSiteFromMenu" title="Return to homepage">
      ‚Üê Back to Site
    </button>
    <!-- Theme toggle positioned in top-right of menu -->
    <button class="theme-toggle menu-theme-toggle" id="themeMenuToggle" title="Change Theme">
      üé®
    </button>
  </div>
  
  <!-- Instructions -->
  <div id="instructionsOverlay" class="game-overlay hidden">
    <div class="overlay-content">
      <h2 class="overlay-title">How to Play</h2>
      <div class="instructions">
        <h3>Objective</h3>
        <p>Guide the snake to eat food and grow longer. Each food eaten increases your score.</p>
        
        <h3>Controls</h3>
        <p>
          <strong>Desktop:</strong> Use WASD or Arrow Keys to move<br>
          <strong>Mobile:</strong> Use on-screen buttons or swipe gestures<br>
          <strong>Pause:</strong> Press Space or P
        </p>
        
        <h3>Rules</h3>
        <p>
          ‚Ä¢ Don't hit the walls<br>
          ‚Ä¢ Don't hit your own tail<br>
          ‚Ä¢ Speed increases with each level<br>
          ‚Ä¢ Every 5 foods advances to next level
        </p>
      </div>
      <button class="game-btn primary" id="backToMenu">Back</button>
    </div>
  </div>
  
  <!-- Pause Menu -->
  <div id="pauseOverlay" class="game-overlay hidden">
    <div class="overlay-content">
      <h2 class="overlay-title">Game Paused</h2>
      <button class="game-btn primary" id="resumeGame">Resume</button>
      <button class="game-btn" id="restartGame">Restart</button>
      <button class="game-btn" id="quitToMenu">Main Menu</button>
      <button class="game-btn" id="backToSiteFromPause">‚Üê Back to Site</button>
    </div>
  </div>
  
  <!-- Game Over -->
  <div id="gameOverOverlay" class="game-overlay hidden">
    <div class="overlay-content">
      <h2 class="overlay-title">Game Over!</h2>
      <div class="final-score">
        <span>Final Score</span>
        <span class="final-score-value" id="finalScore">0</span>
        <div class="high-score-message" id="highScoreMessage"></div>
      </div>
      <button class="game-btn primary" id="playAgain">Play Again</button>
      <button class="game-btn" id="backToMenuFromGameOver">Main Menu</button>
      <button class="game-btn" id="backToSiteFromGameOver">‚Üê Back to Site</button>
    </div>
  </div>
</BaseLayout>

<style>
  /* Import global themes */
  @import '../styles/themes.css';

  /* Reset and base styles */
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: Monaco, Menlo, 'Courier New', monospace;
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
  }

  body {
    background-color: var(--bg-primary);
    color: var(--text-primary);
    position: relative;
  }

  /* Game-specific CSS variables */
  :root {
    --game-canvas-bg: var(--bg-secondary);
    --game-snake-head: var(--accent-primary);
    --game-snake-body: var(--accent-secondary);
    --game-food: var(--accent-tertiary);
    --game-text-primary: var(--text-primary);
    --game-text-accent: var(--accent-primary);
    --game-ui-bg: var(--bg-dark);
    --game-ui-border: var(--accent-primary);
    --game-ui-text: var(--text-light);
    --game-glow: var(--gradient-primary-medium);
    --game-grid-lines: var(--gradient-primary-subtle);
  }

  /* Game canvas */
  #gameCanvas {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: var(--game-canvas-bg);
    box-shadow: 0 0 50px var(--game-glow);
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
  }

  /* Score panel */
  .score-panel {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 30px;
    background: var(--bg-secondary);
    padding: 15px 30px;
    border-radius: 30px;
    backdrop-filter: blur(10px);
    border: 2px solid var(--accent-primary);
    z-index: 10;
    opacity: 0.95;
  }

  .score-item {
    text-align: center;
  }

  .score-label {
    display: block;
    font-size: 12px;
    color: var(--text-primary);
    opacity: 0.8;
    text-transform: uppercase;
    margin-bottom: 5px;
  }

  .score-value {
    display: block;
    font-size: 24px;
    font-weight: bold;
    color: var(--text-primary);
  }

  /* Mobile controls */
  .mobile-controls {
    position: absolute;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    z-index: 10;
  }

  .control-pad {
    position: relative;
    width: 180px;
    height: 180px;
  }

  .control-btn {
    position: absolute;
    width: 60px;
    height: 60px;
    background: var(--game-ui-bg);
    border: 2px solid var(--game-ui-border);
    border-radius: 10px;
    color: var(--game-text-accent);
    font-size: 24px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s;
    backdrop-filter: blur(5px);
    opacity: 0.8;
  }

  .control-btn:active {
    background: var(--game-glow);
    transform: scale(0.95);
    opacity: 1;
  }

  .control-up { top: 0; left: 60px; }
  .control-down { bottom: 0; left: 60px; }
  .control-left { top: 60px; left: 0; }
  .control-right { top: 60px; right: 0; }
  .control-pause { top: 60px; left: 60px; }

  /* Game overlays */
  .game-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--bg-primary);
    background-opacity: 0.95;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 100;
    backdrop-filter: blur(5px);
    transition: opacity 0.3s;
  }

  .game-overlay.hidden {
    display: none;
  }

  .overlay-content {
    background: var(--bg-secondary);
    padding: 40px;
    border-radius: 20px;
    text-align: center;
    max-width: 500px;
    width: 90%;
    border: 3px solid var(--game-ui-border);
    box-shadow: 0 0 30px var(--game-glow);
  }

  .game-title {
    font-size: 48px;
    color: var(--game-text-accent);
    margin-bottom: 10px;
    text-shadow: 0 0 20px var(--game-glow);
    letter-spacing: 5px;
  }

  .game-subtitle {
    font-size: 18px;
    color: var(--text-secondary);
    margin-bottom: 30px;
  }

  .overlay-title {
    font-size: 36px;
    color: var(--game-text-accent);
    margin-bottom: 20px;
  }

  .game-btn {
    display: inline-block;
    padding: 15px 30px;
    margin: 10px;
    font-size: 18px;
    font-family: inherit;
    background: transparent;
    color: var(--game-text-accent);
    border: 2px solid var(--game-ui-border);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s;
    text-transform: uppercase;
    letter-spacing: 2px;
  }

  .game-btn:hover {
    background: var(--game-text-accent);
    color: var(--bg-secondary);
    transform: translateY(-2px);
    box-shadow: 0 5px 20px var(--game-glow);
  }

  .game-btn.primary {
    background: var(--game-text-accent);
    color: var(--bg-secondary);
  }

  .game-btn.primary:hover {
    background: var(--accent-secondary);
    border-color: var(--accent-secondary);
  }

  .instructions {
    text-align: left;
    margin: 20px 0;
    color: var(--text-secondary);
    line-height: 1.8;
  }

  .instructions h3 {
    color: var(--game-text-accent);
    margin-bottom: 10px;
  }

  .final-score {
    margin: 30px 0;
  }

  .final-score-value {
    display: block;
    font-size: 48px;
    color: var(--accent-primary);
    font-weight: bold;
    margin: 10px 0;
  }

  .high-score-message {
    font-size: 20px;
    color: var(--accent-tertiary);
    margin-top: 10px;
  }

  /* Touch device detection */
  @media (hover: none) and (pointer: coarse) {
    .mobile-controls {
      display: block;
    }
  }

  /* Theme Toggle Button */
  .theme-toggle {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 50px;
    height: 50px;
    background: var(--game-ui-bg);
    border: 2px solid var(--game-ui-border);
    border-radius: 50%;
    color: var(--game-text-accent);
    font-size: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(10px);
    z-index: 10;
    opacity: 0.8;
  }

  .theme-toggle:hover {
    opacity: 1;
    transform: scale(1.1);
    box-shadow: 0 0 20px var(--game-glow);
  }

  .theme-toggle:active {
    transform: scale(0.95);
  }

  .menu-theme-toggle {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 10;
  }

  /* Menu Navigation Buttons */
  .menu-nav-btn {
    position: absolute;
    top: 20px;
    z-index: 10;
    padding: 8px 12px;
    font-size: 14px;
    font-family: inherit;
    background: var(--bg-secondary);
    color: var(--text-primary);
    border: 2px solid var(--accent-secondary);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    opacity: 0.8;
    text-decoration: none;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .menu-nav-btn:hover {
    opacity: 1;
    transform: scale(1.05);
    background: var(--accent-secondary);
    color: var(--bg-primary);
    box-shadow: 0 0 15px var(--gradient-secondary-medium);
  }

  .menu-back-btn {
    left: 20px;
  }

  /* Home Navigation Link */
  .home-link {
    position: absolute;
    top: 20px;
    left: 20px;
    z-index: 10;
    opacity: 0.8;
    transition: all 0.3s ease;
    text-decoration: none;
  }

  .home-link:hover {
    opacity: 1;
    transform: scale(1.05);
  }

  .home-brand {
    display: flex;
    align-items: center;
    gap: 8px;
    color: var(--text-primary);
    font-size: 14px;
    font-weight: 600;
    padding: 8px 12px;
    background: var(--bg-secondary);
    border: 2px solid var(--accent-primary);
    border-radius: 8px;
    backdrop-filter: blur(10px);
    box-shadow: 0 0 10px var(--game-glow);
  }

  .home-icon {
    font-size: 16px;
  }

  .home-text {
    white-space: nowrap;
  }

  /* Responsive behavior for home link */
  @media (max-width: 600px) {
    .home-text {
      display: none;
    }
    
    .home-brand {
      padding: 10px;
      min-width: 44px;
      justify-content: center;
    }

    .score-panel {
      top: 10px;
      padding: 10px 20px;
      gap: 20px;
    }

    .score-label {
      font-size: 10px;
    }

    .score-value {
      font-size: 18px;
    }

    .game-title {
      font-size: 36px;
    }

    .overlay-content {
      padding: 30px 20px;
    }

    .mobile-controls {
      bottom: 20px;
    }
  }

  /* Prevent selection and context menu */
  canvas {
    -webkit-tap-highlight-color: transparent;
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
  }
</style>

<!-- Snake Game Logic with Client-side JavaScript -->
<script>
  // Snake Game Implementation
  class SnakeGame {
    config: any;
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    gameState: string;
    snake: any[];
    direction: any;
    nextDirection: any;
    food: any;
    score: number;
    highScore: number;
    level: number;
    foodsEaten: number;
    gameLoop: any;
    currentSpeed: number;
    tileCount: number;
    lastTouchX: number | null;
    lastTouchY: number | null;

    constructor() {
      this.config = {
        gridSize: 20,
        baseSpeed: 120,
        speedIncrement: 10,
        foodsPerLevel: 5
      };
      
      this.canvas = document.getElementById('gameCanvas') as HTMLCanvasElement;
      this.ctx = this.canvas.getContext('2d')!;
      
      this.gameState = 'menu';
      this.snake = [];
      this.direction = { x: 0, y: 0 };
      this.nextDirection = { x: 0, y: 0 };
      this.food = { x: 0, y: 0 };
      this.score = 0;
      this.highScore = 0;
      this.level = 1;
      this.foodsEaten = 0;
      this.gameLoop = null;
      this.currentSpeed = this.config.baseSpeed;
      this.tileCount = 0;
      this.lastTouchX = null;
      this.lastTouchY = null;
      
      this.init();
    }

    init() {
      this.setupCanvas();
      this.loadHighScore();
      this.updateHighScoreDisplay();
      this.setupEventListeners();
      this.showMenu();
      this.initThemeIntegration();
    }

    initThemeIntegration() {
      // Apply current theme from localStorage - force reset to default if it's forest
      let savedTheme = localStorage.getItem('portfolio-theme') || 'default';
      
      // If the saved theme is invalid, reset to default
      const validThemes = ['default', 'electric', 'retro', 'system', 'high-contrast', 'minimal', 'neon'];
      if (!validThemes.includes(savedTheme)) {
        savedTheme = 'default';
        localStorage.setItem('portfolio-theme', 'default');
      }
      
      document.documentElement.setAttribute('data-theme', savedTheme);
      
      // Theme toggle functionality
      const themeToggle = document.getElementById('themeToggle');
      const themeMenuToggle = document.getElementById('themeMenuToggle');
      
      [themeToggle, themeMenuToggle].forEach(toggle => {
        if (toggle) {
          toggle.addEventListener('click', () => {
            this.cycleTheme();
          });
        }
      });
    }

    cycleTheme() {
      const themes = ['default', 'electric', 'retro', 'system', 'high-contrast', 'minimal', 'neon'];
      const currentTheme = document.documentElement.getAttribute('data-theme') || 'default';
      const currentIndex = themes.indexOf(currentTheme);
      const nextIndex = (currentIndex + 1) % themes.length;
      const nextTheme = themes[nextIndex];
      
      document.documentElement.setAttribute('data-theme', nextTheme);
      localStorage.setItem('portfolio-theme', nextTheme);
      
      // Update colors and redraw if game is active
      setTimeout(() => {
        if (this.gameState === 'playing' || this.gameState === 'paused') {
          this.draw();
        }
      }, 100);
    }

    getGameColors() {
      const computedStyle = getComputedStyle(document.documentElement);
      return {
        background: computedStyle.getPropertyValue('--game-canvas-bg').trim(),
        snakeHead: computedStyle.getPropertyValue('--game-snake-head').trim(),
        snakeBody: computedStyle.getPropertyValue('--game-snake-body').trim(),
        food: computedStyle.getPropertyValue('--game-food').trim(),
        gridLines: computedStyle.getPropertyValue('--game-grid-lines').trim()
      };
    }

    setupCanvas() {
      const resize = () => {
        const maxWidth = window.innerWidth * 0.9;
        const maxHeight = window.innerHeight * 0.8;
        const size = Math.min(maxWidth, maxHeight);
        const gridSize = Math.floor(size / this.config.gridSize) * this.config.gridSize;
        
        this.canvas.width = gridSize;
        this.canvas.height = gridSize;
        this.tileCount = gridSize / this.config.gridSize;
        
        if (this.gameState === 'playing' || this.gameState === 'paused') {
          this.draw();
        }
      };
      
      resize();
      window.addEventListener('resize', resize);
    }

    setupEventListeners() {
      // Keyboard controls
      document.addEventListener('keydown', (e) => this.handleKeyPress(e));
      
      // Touch controls
      this.canvas.addEventListener('touchstart', (e: TouchEvent) => this.handleTouchStart(e), { passive: false });
      this.canvas.addEventListener('touchmove', (e: TouchEvent) => this.handleTouchMove(e), { passive: false });
      this.canvas.addEventListener('touchend', (e: TouchEvent) => this.handleTouchEnd(e), { passive: false });
      
      // Mobile control buttons
      document.querySelectorAll('.control-btn[data-direction]').forEach(btn => {
        btn.addEventListener('click', () => {
          const dir = (btn as HTMLElement).dataset.direction;
          if (this.gameState === 'playing') {
            this.changeDirection(dir);
          }
        });
      });
      
      document.getElementById('mobilePause')?.addEventListener('click', () => this.togglePause());
      
      // Menu buttons
      document.getElementById('startGame')?.addEventListener('click', () => this.startGame());
      document.getElementById('showInstructions')?.addEventListener('click', () => this.showInstructions());
      document.getElementById('backToMenu')?.addEventListener('click', () => this.showMenu());
      
      // Navigation buttons
      document.getElementById('backToSiteFromMenu')?.addEventListener('click', () => {
        window.location.href = '/';
      });
      
      // Pause menu buttons
      document.getElementById('resumeGame')?.addEventListener('click', () => this.resumeGame());
      document.getElementById('restartGame')?.addEventListener('click', () => {
        this.hideAllOverlays();
        this.startGame();
      });
      document.getElementById('quitToMenu')?.addEventListener('click', () => {
        this.stopGameLoop();
        this.showMenu();
      });
      document.getElementById('backToSiteFromPause')?.addEventListener('click', () => {
        window.location.href = '/';
      });
      
      // Game over buttons
      document.getElementById('playAgain')?.addEventListener('click', () => {
        this.hideAllOverlays();
        this.startGame();
      });
      document.getElementById('backToMenuFromGameOver')?.addEventListener('click', () => this.showMenu());
      document.getElementById('backToSiteFromGameOver')?.addEventListener('click', () => {
        window.location.href = '/';
      });
    }

    handleKeyPress(e: KeyboardEvent) {
      // ESC key - navigate to homepage
      if (e.key === 'Escape') {
        e.preventDefault();
        if (this.gameState === 'playing') {
          if (confirm('Leave the game and return to homepage?')) {
            window.location.href = '/';
          }
        } else {
          window.location.href = '/';
        }
        return;
      }
      
      if (this.gameState === 'menu' || this.gameState === 'gameover') {
        return;
      }
      
      // Pause controls
      if (e.key === ' ' || e.key.toLowerCase() === 'p') {
        e.preventDefault();
        this.togglePause();
        return;
      }
      
      // Movement controls
      if (this.gameState === 'playing') {
        switch(e.key.toLowerCase()) {
          case 'arrowup':
          case 'w':
            this.changeDirection('up');
            break;
          case 'arrowdown':
          case 's':
            this.changeDirection('down');
            break;
          case 'arrowleft':
          case 'a':
            this.changeDirection('left');
            break;
          case 'arrowright':
          case 'd':
            this.changeDirection('right');
            break;
        }
      }
    }

    handleTouchStart(e: TouchEvent) {
      e.preventDefault();
      const touch = e.touches[0];
      this.lastTouchX = touch.clientX;
      this.lastTouchY = touch.clientY;
    }

    handleTouchMove(e: TouchEvent) {
      e.preventDefault();
    }

    handleTouchEnd(e: TouchEvent) {
      e.preventDefault();
      if (!this.lastTouchX || !this.lastTouchY || this.gameState !== 'playing') {
        return;
      }
      
      const touch = e.changedTouches[0];
      const deltaX = touch.clientX - this.lastTouchX;
      const deltaY = touch.clientY - this.lastTouchY;
      
      // Determine swipe direction
      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        // Horizontal swipe
        if (deltaX > 30) {
          this.changeDirection('right');
        } else if (deltaX < -30) {
          this.changeDirection('left');
        }
      } else {
        // Vertical swipe
        if (deltaY > 30) {
          this.changeDirection('down');
        } else if (deltaY < -30) {
          this.changeDirection('up');
        }
      }
      
      this.lastTouchX = null;
      this.lastTouchY = null;
    }

    changeDirection(dir: string) {
      switch(dir) {
        case 'up':
          if (this.direction.y === 0) {
            this.nextDirection = { x: 0, y: -1 };
          }
          break;
        case 'down':
          if (this.direction.y === 0) {
            this.nextDirection = { x: 0, y: 1 };
          }
          break;
        case 'left':
          if (this.direction.x === 0) {
            this.nextDirection = { x: -1, y: 0 };
          }
          break;
        case 'right':
          if (this.direction.x === 0) {
            this.nextDirection = { x: 1, y: 0 };
          }
          break;
      }
    }

    showMenu() {
      this.gameState = 'menu';
      this.hideAllOverlays();
      document.getElementById('menuOverlay')?.classList.remove('hidden');
      this.clearCanvas();
    }

    showInstructions() {
      this.hideAllOverlays();
      document.getElementById('instructionsOverlay')?.classList.remove('hidden');
    }

    togglePause() {
      if (this.gameState === 'playing') {
        this.pauseGame();
      } else if (this.gameState === 'paused') {
        this.resumeGame();
      }
    }

    pauseGame() {
      this.gameState = 'paused';
      this.stopGameLoop();
      document.getElementById('pauseOverlay')?.classList.remove('hidden');
    }

    resumeGame() {
      this.gameState = 'playing';
      this.hideAllOverlays();
      this.startGameLoop();
    }

    hideAllOverlays() {
      const overlays = ['menuOverlay', 'instructionsOverlay', 'pauseOverlay', 'gameOverOverlay'];
      overlays.forEach(id => {
        document.getElementById(id)?.classList.add('hidden');
      });
    }

    startGame() {
      this.hideAllOverlays();
      this.resetGame();
      this.gameState = 'playing';
      this.startGameLoop();
    }

    resetGame() {
      const centerX = Math.floor(this.tileCount / 2);
      const centerY = Math.floor(this.tileCount / 2);
      this.snake = [{ x: centerX, y: centerY }];
      
      this.direction = { x: 0, y: 0 };
      this.nextDirection = { x: 0, y: 0 };
      this.score = 0;
      this.level = 1;
      this.foodsEaten = 0;
      this.currentSpeed = this.config.baseSpeed;
      
      this.updateScore();
      this.updateLevel();
      this.generateFood();
    }

    startGameLoop() {
      this.stopGameLoop();
      this.gameLoop = setInterval(() => this.update(), this.currentSpeed);
    }

    stopGameLoop() {
      if (this.gameLoop) {
        clearInterval(this.gameLoop);
        this.gameLoop = null;
      }
    }

    update() {
      this.direction = { ...this.nextDirection };
      
      if (this.direction.x !== 0 || this.direction.y !== 0) {
        const head = { ...this.snake[0] };
        head.x += this.direction.x;
        head.y += this.direction.y;
        
        // Check wall collision
        if (head.x < 0 || head.x >= this.tileCount || head.y < 0 || head.y >= this.tileCount) {
          this.endGame();
          return;
        }
        
        // Check self collision
        for (let segment of this.snake) {
          if (head.x === segment.x && head.y === segment.y) {
            this.endGame();
            return;
          }
        }
        
        this.snake.unshift(head);
        
        // Check food collision
        if (head.x === this.food.x && head.y === this.food.y) {
          this.eatFood();
        } else {
          this.snake.pop();
        }
      }
      
      this.draw();
    }

    eatFood() {
      this.score++;
      this.foodsEaten++;
      this.updateScore();
      
      if (this.foodsEaten >= this.config.foodsPerLevel) {
        this.levelUp();
      }
      
      this.generateFood();
    }

    levelUp() {
      this.level++;
      this.foodsEaten = 0;
      this.currentSpeed = Math.max(50, this.config.baseSpeed - (this.level - 1) * this.config.speedIncrement);
      this.updateLevel();
      
      if (this.gameState === 'playing') {
        this.startGameLoop();
      }
    }

    generateFood() {
      do {
        this.food = {
          x: Math.floor(Math.random() * this.tileCount),
          y: Math.floor(Math.random() * this.tileCount)
        };
      } while (this.snake.some((segment: any) => segment.x === this.food.x && segment.y === this.food.y));
    }

    updateScore() {
      const scoreEl = document.getElementById('currentScore');
      if (scoreEl) scoreEl.textContent = this.score.toString();
    }

    updateLevel() {
      const levelEl = document.getElementById('level');
      if (levelEl) levelEl.textContent = this.level.toString();
    }

    loadHighScore() {
      const saved = localStorage.getItem('snakeHighScore');
      if (saved) {
        this.highScore = parseInt(saved, 10);
      }
    }

    saveHighScore() {
      localStorage.setItem('snakeHighScore', this.highScore.toString());
    }

    updateHighScoreDisplay() {
      const highScoreEl = document.getElementById('highScore');
      if (highScoreEl) highScoreEl.textContent = this.highScore.toString();
    }

    endGame() {
      this.gameState = 'gameover';
      this.stopGameLoop();
      
      // Check high score
      const finalScoreEl = document.getElementById('finalScore');
      const highScoreMessageEl = document.getElementById('highScoreMessage');
      
      if (this.score > this.highScore) {
        this.highScore = this.score;
        this.saveHighScore();
        this.updateHighScoreDisplay();
        if (highScoreMessageEl) highScoreMessageEl.textContent = 'New High Score!';
      } else {
        if (highScoreMessageEl) highScoreMessageEl.textContent = '';
      }
      
      if (finalScoreEl) finalScoreEl.textContent = this.score.toString();
      
      document.getElementById('gameOverOverlay')?.classList.remove('hidden');
    }

    draw() {
      this.clearCanvas();
      this.drawGrid();
      this.drawFood();
      this.drawSnake();
    }

    clearCanvas() {
      const colors = this.getGameColors();
      this.ctx.fillStyle = colors.background;
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    drawGrid() {
      const colors = this.getGameColors();
      this.ctx.strokeStyle = colors.gridLines;
      this.ctx.lineWidth = 1;
      
      for (let i = 0; i <= this.tileCount; i++) {
        const pos = i * this.config.gridSize;
        
        this.ctx.beginPath();
        this.ctx.moveTo(pos, 0);
        this.ctx.lineTo(pos, this.canvas.height);
        this.ctx.stroke();
        
        this.ctx.beginPath();
        this.ctx.moveTo(0, pos);
        this.ctx.lineTo(this.canvas.width, pos);
        this.ctx.stroke();
      }
    }

    drawSnake() {
      const colors = this.getGameColors();
      this.snake.forEach((segment: any, index: number) => {
        const x = segment.x * this.config.gridSize;
        const y = segment.y * this.config.gridSize;
        const size = this.config.gridSize - 2;
        
        if (index === 0) {
          this.ctx.fillStyle = colors.snakeHead;
          this.ctx.shadowBlur = 10;
          this.ctx.shadowColor = colors.snakeHead;
        } else {
          this.ctx.fillStyle = colors.snakeBody;
          this.ctx.shadowBlur = 0;
        }
        
        this.ctx.fillRect(x + 1, y + 1, size, size);
        
        // Draw eyes on head
        if (index === 0 && (this.direction.x !== 0 || this.direction.y !== 0)) {
          this.ctx.fillStyle = '#000';
          const eyeSize = 3;
          const eyeOffset = 6;
          
          if (this.direction.x === 1) { // Right
            this.ctx.fillRect(x + size - eyeOffset, y + 5, eyeSize, eyeSize);
            this.ctx.fillRect(x + size - eyeOffset, y + size - 8, eyeSize, eyeSize);
          } else if (this.direction.x === -1) { // Left
            this.ctx.fillRect(x + eyeOffset - eyeSize, y + 5, eyeSize, eyeSize);
            this.ctx.fillRect(x + eyeOffset - eyeSize, y + size - 8, eyeSize, eyeSize);
          } else if (this.direction.y === -1) { // Up
            this.ctx.fillRect(x + 5, y + eyeOffset - eyeSize, eyeSize, eyeSize);
            this.ctx.fillRect(x + size - 8, y + eyeOffset - eyeSize, eyeSize, eyeSize);
          } else if (this.direction.y === 1) { // Down
            this.ctx.fillRect(x + 5, y + size - eyeOffset, eyeSize, eyeSize);
            this.ctx.fillRect(x + size - 8, y + size - eyeOffset, eyeSize, eyeSize);
          }
        }
      });
      
      this.ctx.shadowBlur = 0;
    }

    drawFood() {
      const colors = this.getGameColors();
      const x = this.food.x * this.config.gridSize;
      const y = this.food.y * this.config.gridSize;
      const size = this.config.gridSize - 2;
      const centerX = x + this.config.gridSize / 2;
      const centerY = y + this.config.gridSize / 2;
      
      this.ctx.shadowBlur = 15;
      this.ctx.shadowColor = colors.food;
      
      this.ctx.fillStyle = colors.food;
      this.ctx.beginPath();
      this.ctx.arc(centerX, centerY, size / 2, 0, Math.PI * 2);
      this.ctx.fill();
      
      // Pulse effect
      const pulse = Math.sin(Date.now() * 0.005) * 0.1 + 0.9;
      this.ctx.globalAlpha = pulse;
      this.ctx.beginPath();
      this.ctx.arc(centerX, centerY, size / 2.5, 0, Math.PI * 2);
      this.ctx.fill();
      this.ctx.globalAlpha = 1;
      
      this.ctx.shadowBlur = 0;
    }
  }

  // Initialize the Snake Game
  new SnakeGame();
</script>